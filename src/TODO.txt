背景の透明度について
システムに持たせてプレイヤーがギミックで明るくできるとか
そういうの面白そう

後考えてるのはハートを取るアイテムにして
取ったら消えるようにする・・
フラグを用意すればできそう
フラグがオフなら描画されないので
あとCPU側でも衝突判定に入れないように考慮する

当面はグリッドかな
配置しやすくしたいので
16x16を最小単位にして4x4でモザイクしたい感じかしらね
32x32でゴール
320なので±20のあれであれです。
goalPosもグリッドの交点を指定してそこを角に持つ16x16が4つ、
そういう32x32にすれば指定しやすそう。
回転させる場合はフェイズと回転方向おねがいね実装

クリアしたらゴールのとこがグローで光るようにするとかしたいね
で、連続してパーティクル出す。複数ある場合は複数をそういう状態に
できたらクリアみたいなの面白そうね

ATOMにやってきました。Hello!!!

今、グリッド的に-20,-20～20,20でこれが640x640の場合。
640x1280とかならこれに対しても最小サイズの16を適用して-20,-40～20,40とかする感じね。で、
createWallもそれに応じたものになるわけ。それでいいと思う。後は同じ。
あとシェーダの方でもちゃんと640で割る。そうすればたとえば1280x1280とかでもちゃんと-40,-40～40,40になってくれるから
同じように指定できるわね。

どうするかな。
まあ、やられたら最初に戻すか。ライフをね・・リセットするかどうかって話。
ルームナンバーを0に戻す、っていう。つまりライフの減少を持ち越すかどうかって話。持ち越した方がいいと思う。
あとは回復アイテム作ればいいでしょ。
つまりゲームオーバーからは問答無用で0に戻すと。で、クリアの場合はプレイヤーのライフを戻さない感じで。

でもそのうちSTG要素というか弾幕も用意したいなって思ってて・・
その場合はパーティクルの発生場所をあれにしないとやばいわけで。やられる時だけならいいけど。だからそこら辺。
ダブルシェーダ（板ポリ芸とポイントシェーダーの合わせ技）
まあいいやそういうのは要らないからとりあえず
高速描画が必要なほど弾幕用意したら別のゲームになっちゃうから

saveJSONっていうのがあってね。
これ使うとJSON形式でデータを取り出せる・・もちろんロードも揃ってる。

room0はチュートリアルっぽくする（目玉が1つ中央上でぐるぐるしててそのすぐ下にゴールがあって
それ踏んだらクリアだよみたいな感じ）

ゴールを増やす。名前もゴール→チェックポイントに変える。
チェックポイントをすべて発光させるとクリアフラグが立つ。OK!

あと次の3点で終わりにする
1: オブジェクトの位置・回転の情報をuniform登録して別立て処理にする。シェーダーの組み立て部分もいじる。これにより、
オブジェクトの位置と回転を自由に操作できるようになるわけ。動くオブジェクトは当たるとアウト、それを実装するには
どれに当たったかの情報とそれが動いているかどうかを返すフラグが必要になる。動いてなければダメージはないのでそこら辺の
処理も必要ね。
2: ゴールを複数にする。ゴールではなくチェックポイントという名称にする。まずはそこら辺をいじる必要。で、すべてのチェックポイントを
回るとクリアとする。まあそんな感じ。
修正。チェックポイントはスカイブルー、それとは別にライムグリーンで大きめ(64x64)のゴールを作る。そこが解放される。判定は同じ。
中心いかないとだめ。おわり。チェックポイントは最大8つで個数も送る。
3: 大きなステージ。640x1280とか1280x1280とか作りたいわね。で、オフセット描画。これはそこまで難しくないと思う。
baseGraphicとlightEffectをその大きさにして描画するときに画面サイズに合わせる、どう合わせるかはオフセット計算。
そのくらいしかやることがないので。あとそうね、今-1～1x-1～1でやってるのが-2～2x-1～1になったりするわね。そこら辺、
指定の仕方とかはいじる必要あるけどほんとにそのくらいしかないと思う。
4.残基数・・残基は難易度別に3,5,10で。これが0にならなければそのステージの最初からHP全快で再開できるが0になったら最初に戻される、
その際にスコア的な何か、数字では評価しない。クリアステージ数、それらのクリアにかかった時間（そのステージで死ぬまでの時間は含まれない）、
残りライフ、残り残基。で、ランクシステムも考えてないわけじゃないよ。タイムアタック部門とライフ部門。どちらもクリアステージ数大きいのが上。
その先はタイムアタックならタイム→残基→ライフの順で評価、ライフなら残基→ライフ→タイムの順で評価。おわり。

おわり。

1.について処理切り分け
obj用のシェーダーテキストを作るところを書き換える。具体的にはsetUniformでxとyについての情報を送るので、それの
だからベクトルv[0].x,v[0].yみたいのにする、わけ。0とか1とか織り込んで。で、それは毎フレーム更新。要するに別の関数を作るのね。
そこに今は定数でいいからそれを定める関数を用意するわけです。今は定数でいい。まるごと移植。
まあ回転も織り込んじゃうかめんどくさい。そうなるとフェイズ（最初の位相）も必要になるわね。
図形の定義のところは大幅に書き換える必要性。
動いてるかどうかのフラグも用意。それを動かすためのメソッドも必要になる（動いたり止まったりするわけで）。
そこら辺のアクションは敵の動きもそうだけど定義しやすくしないとめんどくさい。この辺はすべてCPU管理。シェーダには値を渡すだけなので。

動きって別のクラスに分けるべきなのね・・いちいち書くのあれだもんね。
てかスケールも？UnityもBlenderもそこら辺・・ああ、そうか。スケール変換も織り込むことにすれば
正方形も長方形も変わらんし、円も楕円も変わらんわね。んー・・てことはあれ、あー、線分も？そうね・・んー。
線分は変なことになりそうだけど。あと三角形？正三角形でなくなるけど計算がおかしくなるわけじゃない、まあでもあれ、んー・・
なるほど・・・どうするかね。

//--- 仕様変更log(2021/10/31) ---//

予想通りえらいことになった
まずheartは封印（segment仕様変更したので）
そこまではいい
どゆこと？？？？？
rotの0を入れることになったんでそこら辺
createWallのあとでregistObstaclesするんだっけ間違えた
じゃああの十字はセグメント？？？
segmentのconstructorでx,y,rot抜けてましたごめんなさい！！
んー・・もしかして光のもとにいないときにダメージ受けてる？？でも何で？？
てかキー入力も反応してない。光の範囲はOK.うーん・・・
動いた先がobstacleと接触だと動けないことになってるからキー入力じゃなくてDistFunctionが問題なんだろていうかgetDist()だよ
そこしかいじってないんだから
光の範囲が正常なのはGLSL側で計算してるからだよだからgetDistに原因があると考えるのが妥当。
あ、translateがcosとsin1箇所間違って・・た・・・ごめ・・・
バグ取れたと思ったらroom1がバグってる（おい）
間違ってるのは表示位置だけで当たり判定は問題ないっぽい。。
GLSL側に問題があるようですね
registObstaclesしてなかった（え・・）
できた！
あとは動かしたいオブジェクトだけそういうたぐいの関数ぶちこめばそこだけ動くようにできるし
距離計算でどれに接触したか、の情報を取得するようにすればそれでプレイヤーを殺すこともできるね！（物騒）

じゃあチェックポイントいきますかね・・

いっくぞー！！！
CheckがCheclになってた（こら）
ゴールの見た目がおかしいな・・原因は何？
あーなるほど・・チェックポイントはあらかじめ黒にしてあるから・・
ゴールもそうしよう。
ただし出てるときだけね。シークレットなので。
まあ、これで・・あと増やしといて。んー、8つとかでもいいかな・・まあいくらでも増やせるのでね。

オフセット。これをやるには、まず全体の大きさ・・んー。オフセットね・・
baseGraphicと_lightEffectを任意の大きさ（たとえば1280x640とか）に設定する。
プレイヤーの位置に応じて部分的に描画する。計算の仕方・・
(sx,sy)これはステージの大きさ（1280x640とか）
(dx,dy)これはキャンバスの大きさ（今現在640x640)
で。。結局、
image(gr, 0, 0, width, height, a, b, width, height);
a = constrain(x-dx/2, 0, sx-dx);
b = constrain(y-dy/2, 0, sy-dy); ですね！

createWallだっけ。えーと。中心が(0,0)でですね・・GRIDが1/20なのでね。それで40,1と1,40
この40というのは640/16で出すので1280なら80なわけですね。960なら960/16で60ですね。
19.5とかは20から0.5を引く・・
一応640x640が最小サイズで320の倍数で大きくしていく予定ですね。
w*hだとしてこれをw/32|0とh/32|0だしてですね、たとえば20,20だと。通常ね。で、
0,±19.5の40,1と±19.5,0の1,40.
20,30の場合。
0,±29.5の40,1と±19.5の1,60ですね。
30,40の場合
0,±39.5の60,1と±29.5の1,80ですね。はい。OK.
大きさ変えるのはresizeCanvasで簡単にできるので
複数のグラフィックを用意する必要はありません（やったね）

てすとしたけどわからんね
大きいの用意して・・
先にcreateWallの仕様変更して
あ！実位置！！
プレイヤーが動けませんが・・バウンドチェック外しました。
で、まあ正方形でいいのかってのはあるけど・・まあいいか、SIZEって用意して640で固定するかな・・んー。
たとえば表示先が800x640でもうまくいくのかというね。その場合160x640がブランクになるけど。
さてと。んー・・やる？いいか別に。んー・・

プレイヤーのサイズを32x32にして当たり判定を更新
残基数を用意して残基が0にならないならゲームオーバーせずそのステージをHP全快でやり直し
その場合メッセージは表示されず残基が0のときのみゲームオーバーして最初に戻る

stage内のポジション情報をグローバルに直す（そのキャンバス内での0,0～w,hに直す）関数を用意して使い回すか

え？バリア・・・？
仕様作るね・・（冗談でしょ？？）
BG(バリアゲージ)MAXのときシフトボタンで発動
押してる間ずっと展開される、光は円判定で遮蔽されるのでダメージを受けない（リングみたいな感じね）てかグローするリング
しかし離すと自動的にゲージが回復してMAXになるまで展開できない
ゲージが消えるアニメは同じものを使います（パーティクル）
リングのあれ？パルックみたいなのでいいんじゃない。光輪みたいなやつ。グロー掛けて。色はそうね・・navyとかその辺？んー。。
ゲージの色も青系で。

じゃあ次の仕様変更は残基数とバリアで・・んー。

仕様変更ラスト
1.残基数用意。プロパティ名はrestでいいです。rest=3とか10とか。同じアイコンを貼り付ける。個数だけ。
  残基が0にならないなら同じステージをライフ全快でやり直し。残基0なら最初から。
2.動くオブジェクトに当たるならアウト。この場合ゲージパーティクルは端っこから1/20おきに発生させる（最大20）

綺麗ではないけどまあいいや。あとはゲームオーバーまたは全ステージクリアの場合にリザルトへ行くけど、そこはまあいくらでもできるわね。
時間？？
計測はステージ開始からアウトになるまで。これを積み重ねる。最終的にスコアになるのはクリア時点でのellapsedTimeで、
途中でやられた場合は最後にクリアしたステージまでのリザルトがなんか、あれになる感じ。
リザルトクラス。記録するのはellapsedTimeと残基数と残りライフの割合とクリアしたステージ数（最初のステージでやられた場合は0）
クリアしたステージ数は一番最初に比較される対象なのでこれが0の場合問答無用でびりけつ。
構造体でもいいけど

gameoverFlagっていう言い方がもう使えないのか。じゃあkilledFlagで置き換えるね。
今現在resultを運用するのは無理。今の仕様だと全クリしたあと戻っちゃうから区別できないし。まあいいよ。

とりあえず終わりました。テンプレに移す準備をします。しばらくお待ちください。

どうでもいいんだけどクリアした時に体が15フレームで横につぶれた後15フレームで縦につぶれて30フレームでパーティクル出して消えるのやりたい
無茶いうね
小さめでいいから
updateで動くの禁止して描画に特別なメソッド使えば簡単でしょ。

step1: プレイヤー描画を画像貼り付けにする
step2: 画像貼り付けで工夫すればつぶれたりなんだりかんだりってのは余裕。30フレーム以降は消えてしまうので描画しない
step3: system側でしかるべく処理する（clearFlagが立っていたらupdateしない、など）

移植
まずprepareでroomInitializeするわけ
roomたちを格納する処理が必要なのよね・・んー。
distFunctionとかグローバルでいいの？って思うけどこればかりは仕方ないわね
あー、そうよ。prepareはここに来た時の処理。
pauseがないなら、タイトルからくるわけだから普通にroomInitialize1回やるだけ。
それ以降は中でいろいろやるので・・
で、オールクリアもしくはゲームオーバーでのみゲームが終了する感じ（どっちもリザルトに飛ぶ）
もちろんエスケープも用意しておくけど
1回押したらタイトルに戻る的な？
あとはグラフィック渡してそこに描画させるようにするだけか。
難しく、ないな・・・

roomInitializeとは別に、initialize(難易度)を使いましょう。タイトルからセレクトした難易度を受け取って
プレイヤーの残基数を決める（6,8,10くらいで）。それだけ。難しい場合、敵の動きについて若干の変更・・
たとえば移動速度とかライトの回るのが速くなるとかそういうの。障害物の移動スピードも。そんくらいで。
単に残基数だけだとなんていうか難易度変えてる感じがしないので。0.9倍と1.1倍くらいでいいから。
createEyePatternとかcreateObjectPatternにlevelを渡せばいいかしらね・・

Title, Play, Result.

最後にリザルトクラスを実装してinitializeでリセットしてステージクリアの際に更新しつつ時間も計って
リザルトに渡して結果を出してもらえばやることは全部終了かしらね。ステージ作ってませんが。

画像作ったのでシーン遷移始めちゃおう。
translateは意味的にはtransformなのとtranslateが予約語なので使用禁止
あとdxとdyグローバルにするのやばいので修正

flow.
タイトル画面で十字キー上下で操作して（ただしループはさせない行き過ぎたらそれ以上いかない）
難易度を設定してエンターキーぽちっ
プレイ画面に行きます
その際にレベルに応じてとりあえず残基数だけでいいのでそれを設定しますね
10, 6, 3でいく
そんで描画についてはgrを渡してそこに描画させるように修正が必要です
リザルトクラスに仕事してもらう
いろいろ終わったらリザルトを描画してエンターキーでタイトルに戻す
以上！

状態遷移・・・
clearCheckのあとステージナンバーがカンストする場合ってのがあるんだけどそこでフラグを設定
ゲームオーバーの場合もチェック後にフラグを設定できる
そこで離脱してしまえばいい

お疲れさまでした。あとはリザルトがきちんと機能しているかチェックなどそこら辺ですかね・・・

ちょっと修正
累積ダメージを記録しておいて最後にまとめて計算してからゲージの然るべき場所にパーティクルを発生させると同時に
HPを減らしてその結果で死んだかどうかチェックする形にしたい
今の形式だとHP減る要因作るたびにいちいち泥臭い修正が入ってしまうので
それがひとつであとふたつ
まず動きについて
位置とイージングで簡単にtweenさせます
方向とかスカラーについても、というかスカラーとベクトル両方で。そんくらいでいいよ。んー、規則的な動きだけでいいのかって？
そうね。。。
こっちを向くとかできないですからね。どうしましょうね。まあでもボスとかだすわけじゃないしVVVVVV的な感じでいいんじゃないですかね
あとあれタイムを常時表示させます
これはフェードインアウト関係なく常に表示なのでinfoですねまあ属性がinfoですから
で
まあこれはリザルトにそれ返す機構備えれば済む話ですね
以上

// 更新ログ //
んー・・計算方法おかしい？？
わかった
timerOnを最初にその部屋に入った時に1回だけ実行されるようにしないといけないんだ
system側をいじってもいいけどまあresult側をいじるのが適切でしょうね
roomInFlagがfalseのときに1回だけtimerOnしてフラグオフ、クリア時のupdateでフラグを戻せばいいわね。
なかなかに厄介・・

2021/11/09
つづきを・・かいてください・・・
１：タイム
２：ダメージ整理
３：tweenによる記述
ひとつめがおわったので2と3やりたいね！

２：大まかな方針
playerにダメージプロパティを設けてupdateで障害物にぶつかったりしたときに（この場合は全ライフ加算）あるいは目玉の光線に当たった時に
加算していく感じで。changeLifeは廃止。で、代わりにダメージを清算してライフの変化にする処理を用意する。その一方でパーティクルの発生、
これはプレイヤーのその時のHPとダメージ量から計算して発生させる（というかそれがないと場所わからんし）。
getLifeRatioはリザルトでも使うので残しておく。代わりにダメージ量・・んー。ダメージ量÷MAX_LIFEのあれを返す？か。それでいい、よね。
getDamageRatioでまとめて取得。いろいろ取得しすぎるのもあれなので。

おわりました 2021/11/11 簡単でしたね。
３：ですが・・
直線の場合はまあ始点と終点と経過フレーム数とイージングでいいと思う。
円の場合は中心と半径と角度の始点終点とイージングでいいと思う。
光の出る方向はこれも回転スピード、んー。だめか。えーと。始点と終点だけでいいんじゃない。リニアオンリーで。経過フレームと。
フレームでいいのかなってのはあるけどね・・。
クラスにする。で、フレームカウンター持たせる。完了したらなんか返す。返して次のクラスへ。そんな感じで。
ブロックについても同じ感じでよろしくです・・

クラス生成方法
まず今んとこ対象となるのは・・
めんどくさいな
イメージ作っちゃうね

まず1次元なり2次元なりのなんか値、初期値を決めてさ
それを一連の流れに従って変化させていく仕組みを作る
あとは毎フレームそこから値を取り出してセットするだけ
簡単でしょ
対象はeyeのpositionとlightDirection（場合によってはlightRangeも対象）
obstacleのpositionとrotationですかね
そのくらいしか今は思いつかない感じですね
グラフとか作れたらいいんだけど
